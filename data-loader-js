// data-loader.js
/**
 * Data Loader Module
 * Handles CSV parsing, normalization, and dataset preparation for S&P 500 stock data
 */

class DataLoader {
    constructor() {
        this.rawData = null;
        this.normalizedData = null;
        this.min = 0;
        this.max = 0;
        this.X_train = null;
        this.y_train = null;
        this.X_test = null;
        this.y_test = null;
        this.trainSize = 0.8; // 80% training, 20% testing
        this.windowSize = 60; // 60-day window
        this.forecastDays = 5; // Predict next 5 days
    }

    /**
     * Load and parse CSV file from file input
     * @param {File} file - CSV file object
     * @returns {Promise<Array>} - Parsed data array
     */
    async loadCSV(file) {
        return new Promise((resolve, reject) => {
            if (!file) {
                reject(new Error('No file provided'));
                return;
            }

            const reader = new FileReader();
            
            reader.onload = (event) => {
                try {
                    const content = event.target.result;
                    // Parse CSV content (assuming single column of prices)
                    const lines = content.split('\n').filter(line => line.trim() !== '');
                    
                    // Remove possible header and empty values
                    const prices = lines.map(line => {
                        // Handle quoted values and empty strings
                        const val = line.replace(/"/g, '').trim();
                        return val && !isNaN(parseFloat(val)) ? parseFloat(val) : null;
                    }).filter(val => val !== null);
                    
                    if (prices.length === 0) {
                        reject(new Error('No valid numeric data found in CSV'));
                        return;
                    }
                    
                    this.rawData = prices;
                    resolve(prices);
                } catch (error) {
                    reject(new Error(`CSV parsing error: ${error.message}`));
                }
            };
            
            reader.onerror = () => {
                reject(new Error('Failed to read file'));
            };
            
            reader.readAsText(file);
        });
    }

    /**
     * Normalize data using Min-Max scaling
     * @param {Array} data - Raw price data
     * @returns {Array} - Normalized data
     */
    normalizeData(data) {
        if (!data || data.length === 0) {
            throw new Error('No data to normalize');
        }
        
        this.min = Math.min(...data);
        this.max = Math.max(...data);
        
        // Avoid division by zero
        const range = this.max - this.min || 1;
        
        this.normalizedData = data.map(price => (price - this.min) / range);
        return this.normalizedData;
    }

    /**
     * Denormalize data back to original scale
     * @param {Array} normalizedData - Normalized data
     * @returns {Array} - Original scale data
     */
    denormalizeData(normalizedData) {
        if (!this.min && !this.max) {
            throw new Error('Normalization parameters not set');
        }
        
        const range = this.max - this.min;
        return normalizedData.map(val => val * range + this.min);
    }

    /**
     * Create sequences for time series prediction
     * @param {Array} data - Normalized data
     * @param {number} windowSize - Size of input window
     * @param {number} forecastDays - Number of days to predict
     * @returns {Object} - X and y tensors
     */
    createSequences(data) {
        if (data.length < this.windowSize + this.forecastDays) {
            throw new Error(`Data too short. Need at least ${this.windowSize + this.forecastDays} days`);
        }
        
        const X = [];
        const y = [];
        
        for (let i = 0; i < data.length - this.windowSize - this.forecastDays + 1; i++) {
            X.push(data.slice(i, i + this.windowSize));
            y.push(data.slice(i + this.windowSize, i + this.windowSize + this.forecastDays));
        }
        
        return { X, y };
    }

    /**
     * Prepare training and testing datasets
     * @param {Array} rawData - Raw price data
     * @returns {Object} - Training and testing tensors
     */
    prepareDatasets(rawData) {
        // Normalize data
        const normalizedData = this.normalizeData(rawData);
        
        // Create sequences
        const { X, y } = this.createSequences(normalizedData);
        
        // Split into train and test sets
        const splitIndex = Math.floor(X.length * this.trainSize);
        
        const X_train = X.slice(0, splitIndex);
        const y_train = y.slice(0, splitIndex);
        const X_test = X.slice(splitIndex);
        const y_test = y.slice(splitIndex);
        
        // Convert to tensors
        this.X_train = tf.tensor3d(X_train, [X_train.length, this.windowSize, 1]);
        this.y_train = tf.tensor2d(y_train, [y_train.length, this.forecastDays]);
        this.X_test = tf.tensor3d(X_test, [X_test.length, this.windowSize, 1]);
        this.y_test = tf.tensor2d(y_test, [y_test.length, this.forecastDays]);
        
        return {
            X_train: this.X_train,
            y_train: this.y_train,
            X_test: this.X_test,
            y_test: this.y_test,
            trainSize: X_train.length,
            testSize: X_test.length
        };
    }

    /**
     * Get the latest window for prediction
     * @returns {tf.Tensor} - Latest window tensor
     */
    getLatestWindow() {
        if (!this.normalizedData) {
            throw new Error('Data not loaded');
        }
        
        const latestWindow = this.normalizedData.slice(-this.windowSize);
        return tf.tensor3d([latestWindow], [1, this.windowSize, 1]);
    }

    /**
     * Calculate returns from prices
     * @param {Array} prices - Price data
     * @returns {Array} - Returns data
     */
    calculateReturns(prices) {
        const returns = [];
        for (let i = 1; i < prices.length; i++) {
            returns.push((prices[i] - prices[i-1]) / prices[i-1]);
        }
        return returns;
    }

    /**
     * Clean up tensors to free memory
     */
    dispose() {
        if (this.X_train) this.X_train.dispose();
        if (this.y_train) this.y_train.dispose();
        if (this.X_test) this.X_test.dispose();
        if (this.y_test) this.y_test.dispose();
    }

    /**
     * Get dataset statistics
     * @returns {Object} - Dataset statistics
     */
    getStats() {
        if (!this.rawData) {
            return null;
        }
        
        const returns = this.calculateReturns(this.rawData);
        
        return {
            totalDays: this.rawData.length,
            trainSamples: this.X_train ? this.X_train.shape[0] : 0,
            testSamples: this.X_test ? this.X_test.shape[0] : 0,
            minPrice: Math.min(...this.rawData).toFixed(2),
            maxPrice: Math.max(...this.rawData).toFixed(2),
            meanPrice: (this.rawData.reduce((a, b) => a + b, 0) / this.rawData.length).toFixed(2),
            meanReturn: (returns.reduce((a, b) => a + b, 0) / returns.length * 100).toFixed(3),
            volatility: (Math.sqrt(returns.reduce((sq, n) => sq + n * n, 0) / returns.length) * 100).toFixed(3)
        };
    }
}

// Export singleton instance
export const dataLoader = new DataLoader();
