// data-loader.js
class DataLoader {
    constructor() {
        this.rawData = null;
        this.normalizedData = null;
        this.minValues = null;
        this.maxValues = null;
        this.X_train = null;
        this.y_train = null;
        this.X_test = null;
        this.y_test = null;
        this.trainSize = 0.8; // 80% training, 20% testing
        this.featureColumns = [];
    }

    /**
     * Load and parse CSV file
     * @param {File} file - CSV file from file input
     * @returns {Promise<Array>} Parsed data
     */
    async loadCSV(file) {
        return new Promise((resolve, reject) => {
            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: (results) => {
                    if (results.errors.length > 0) {
                        reject(new Error(`CSV parsing errors: ${results.errors.map(e => e.message).join(', ')}`));
                        return;
                    }
                    
                    if (results.data.length === 0) {
                        reject(new Error('CSV file is empty'));
                        return;
                    }

                    // Store raw data
                    this.rawData = results.data;
                    
                    // Extract feature columns (all columns except date)
                    this.featureColumns = Object.keys(results.data[0]).filter(col => 
                        col.toLowerCase() !== 'date' && 
                        col.toLowerCase() !== 'timestamp'
                    );
                    
                    if (this.featureColumns.length === 0) {
                        reject(new Error('No numeric columns found in CSV'));
                        return;
                    }
                    
                    console.log(`Loaded ${results.data.length} rows with ${this.featureColumns.length} features`);
                    resolve(results.data);
                },
                error: (error) => {
                    reject(error);
                }
            });
        });
    }

    /**
     * Calculate daily returns from price data
     * @param {Array} data - Raw price data
     * @returns {Array} Returns data
     */
    calculateReturns(data) {
        const returnsData = [];
        
        for (let i = 1; i < data.length; i++) {
            const returnRow = {};
            const prevRow = data[i - 1];
            const currRow = data[i];
            
            this.featureColumns.forEach(col => {
                if (prevRow[col] !== null && prevRow[col] !== undefined && prevRow[col] !== 0) {
                    returnRow[col] = (currRow[col] - prevRow[col]) / prevRow[col];
                } else {
                    returnRow[col] = 0;
                }
            });
            
            returnsData.push(returnRow);
        }
        
        return returnsData;
    }

    /**
     * Normalize data using Min-Max scaling per feature
     * @param {Array} data - Returns data
     * @returns {Object} Normalized data and scalers
     */
    normalizeData(data) {
        if (!data || data.length === 0) {
            throw new Error('No data to normalize');
        }

        // Initialize min and max arrays
        this.minValues = new Array(this.featureColumns.length).fill(Infinity);
        this.maxValues = new Array(this.featureColumns.length).fill(-Infinity);

        // Find min and max for each feature
        data.forEach(row => {
            this.featureColumns.forEach((col, idx) => {
                const value = row[col];
                if (value < this.minValues[idx]) this.minValues[idx] = value;
                if (value > this.maxValues[idx]) this.maxValues[idx] = value;
            });
        });

        // Normalize data
        this.normalizedData = data.map(row => {
            const normalizedRow = {};
            this.featureColumns.forEach((col, idx) => {
                const range = this.maxValues[idx] - this.minValues[idx];
                if (range === 0) {
                    normalizedRow[col] = 0;
                } else {
                    normalizedRow[col] = (row[col] - this.minValues[idx]) / range;
                }
            });
            return normalizedRow;
        });

        return this.normalizedData;
    }

    /**
     * Create sliding window sequences
     * @param {Array} data - Normalized data
     * @param {number} lookback - Window size
     * @param {number} horizon - Prediction horizon
     * @returns {Object} Features and labels
     */
    createSequences(data, lookback = 60, horizon = 5) {
        if (data.length <= lookback + horizon) {
            throw new Error(`Not enough data for lookback ${lookback} and horizon ${horizon}`);
        }

        const sequences = [];
        const labels = [];

        for (let i = 0; i < data.length - lookback - horizon + 1; i++) {
            // Create sequence (lookback window)
            const sequence = [];
            for (let j = 0; j < lookback; j++) {
                const row = data[i + j];
                const features = this.featureColumns.map(col => row[col]);
                sequence.push(features);
            }

            // Create label (average return over horizon)
            const futureReturns = [];
            for (let j = 0; j < horizon; j++) {
                const row = data[i + lookback + j];
                // Use first feature (S&P 500) as target
                futureReturns.push(row[this.featureColumns[0]]);
            }
            
            // Binary classification: 1 if average future return > 0, else 0
            const avgReturn = futureReturns.reduce((a, b) => a + b, 0) / horizon;
            const label = avgReturn > 0 ? 1 : 0;

            sequences.push(sequence);
            labels.push(label);
        }

        return { sequences, labels };
    }

    /**
     * Prepare training and testing datasets
     * @param {number} lookback - Window size
     * @param {number} horizon - Prediction horizon
     */
    prepareDatasets(lookback = 60, horizon = 5) {
        if (!this.normalizedData) {
            throw new Error('Data not normalized. Call normalizeData first.');
        }

        const { sequences, labels } = this.createSequences(this.normalizedData, lookback, horizon);
        
        // Split chronologically
        const splitIndex = Math.floor(sequences.length * this.trainSize);
        
        // Convert to tensors
        this.X_train = tf.tensor3d(sequences.slice(0, splitIndex));
        this.y_train = tf.tensor2d(labels.slice(0, splitIndex), [splitIndex, 1]);
        this.X_test = tf.tensor3d(sequences.slice(splitIndex));
        this.y_test = tf.tensor2d(labels.slice(splitIndex), [sequences.length - splitIndex, 1]);

        console.log(`Training set: ${this.X_train.shape[0]} samples`);
        console.log(`Testing set: ${this.X_test.shape[0]} samples`);
        console.log(`Sequence shape: [${lookback}, ${this.featureColumns.length}]`);

        return {
            X_train: this.X_train,
            y_train: this.y_train,
            X_test: this.X_test,
            y_test: this.y_test,
            featureCount: this.featureColumns.length
        };
    }

    /**
     * Get the most recent sequence for prediction
     * @param {number} lookback - Window size
     * @returns {tf.Tensor} Sequence tensor
     */
    getLatestSequence(lookback = 60) {
        if (!this.normalizedData || this.normalizedData.length < lookback) {
            throw new Error('Not enough data for prediction');
        }

        const latestData = this.normalizedData.slice(-lookback);
        const sequence = latestData.map(row => 
            this.featureColumns.map(col => row[col])
        );

        return tf.tensor3d([sequence]);
    }

    /**
     * Clean up tensors to free memory
     */
    dispose() {
        if (this.X_train) this.X_train.dispose();
        if (this.y_train) this.y_train.dispose();
        if (this.X_test) this.X_test.dispose();
        if (this.y_test) this.y_test.dispose();
        
        this.X_train = null;
        this.y_train = null;
        this.X_test = null;
        this.y_test = null;
    }
}

export default DataLoader;
